{"version":3,"file":"prismeditor.umd.production.min.js","sources":["../src/Editor.ts"],"sourcesContent":["import Vue, { VNode } from 'vue';\r\n\r\nimport './styles.css';\r\nconst KEYCODE_ENTER = 13;\r\nconst KEYCODE_TAB = 9;\r\nconst KEYCODE_BACKSPACE = 8;\r\nconst KEYCODE_Y = 89;\r\nconst KEYCODE_Z = 90;\r\nconst KEYCODE_M = 77;\r\nconst KEYCODE_ESCAPE = 27;\r\n\r\nconst BRACKET_PAIRS: {[opening: string]: string} = {\r\n  '(':')',\r\n  '{':'}',\r\n  '[':']',\r\n  '\"':'\"',\r\n  \"'\":\"'\",\r\n};\r\n\r\nconst HISTORY_LIMIT = 100;\r\nconst HISTORY_TIME_GAP = 3000;\r\n\r\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\r\nconst isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n\r\nexport interface EditorProps {\r\n  lineNumbers: boolean;\r\n  autoStyleLineNumbers: boolean;\r\n  readonly: boolean;\r\n  value: string;\r\n  highlight: () => string;\r\n  tabSize: number;\r\n  insertSpaces: boolean;\r\n  ignoreTabKey: boolean;\r\n  placeholder: string;\r\n}\r\nexport interface Record {\r\n  value: string;\r\n  selectionStart: number;\r\n  selectionEnd: number;\r\n}\r\n\r\nexport interface History {\r\n  stack: Array<Record & { timestamp: number }>;\r\n  offset: number;\r\n}\r\n\r\nexport const PrismEditor = Vue.extend({\r\n  props: {\r\n    lineNumbers: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    autoStyleLineNumbers: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    readonly: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    value: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n    highlight: {\r\n      type: Function,\r\n      required: true,\r\n    },\r\n    tabSize: {\r\n      type: Number,\r\n      default: 2,\r\n    },\r\n    insertSpaces: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    ignoreTabKey: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    placeholder: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n  },\r\n  data() {\r\n    return {\r\n      capture: true,\r\n      history: {\r\n        stack: [],\r\n        offset: -1,\r\n      } as History,\r\n      lineNumbersHeight: '20px',\r\n      codeData: '',\r\n    };\r\n  },\r\n  watch: {\r\n    value: {\r\n      immediate: true,\r\n      handler(newVal: string): void {\r\n        if (!newVal) {\r\n          this.codeData = '';\r\n        } else {\r\n          this.codeData = newVal;\r\n        }\r\n      },\r\n    },\r\n    content: {\r\n      immediate: true,\r\n      handler(): void {\r\n        if (this.lineNumbers) {\r\n          this.$nextTick(() => {\r\n            this.setLineNumbersHeight();\r\n          });\r\n        }\r\n      },\r\n    },\r\n    lineNumbers(): void {\r\n      this.$nextTick(() => {\r\n        this.styleLineNumbers();\r\n        this.setLineNumbersHeight();\r\n      });\r\n    },\r\n  },\r\n  computed: {\r\n    isEmpty(): boolean {\r\n      return this.codeData.length === 0;\r\n    },\r\n    content(): string {\r\n      const result = this.highlight(this.codeData) + '<br />';\r\n      // todo: VNode support?\r\n      return result;\r\n    },\r\n    lineNumbersCount(): number {\r\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\r\n      return totalLines;\r\n    },\r\n  },\r\n  mounted() {\r\n    this._recordCurrentState();\r\n    this.styleLineNumbers();\r\n  },\r\n\r\n  methods: {\r\n    setLineNumbersHeight(): void {\r\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\r\n    },\r\n    styleLineNumbers(): void {\r\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\r\n\r\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\r\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\r\n      const editorStyles = window.getComputedStyle($editor);\r\n\r\n      this.$nextTick(() => {\r\n        const btlr: any = 'border-top-left-radius';\r\n        const bblr: any = 'border-bottom-left-radius';\r\n        if (!$lineNumbers) return;\r\n        $lineNumbers.style[btlr] = editorStyles[btlr];\r\n        $lineNumbers.style[bblr] = editorStyles[bblr];\r\n        $editor.style[btlr] = '0';\r\n        $editor.style[bblr] = '0';\r\n\r\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\r\n        stylesList.forEach((style: any) => {\r\n          $lineNumbers.style[style] = editorStyles[style];\r\n        });\r\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\r\n      });\r\n    },\r\n    _recordCurrentState(): void {\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n\r\n      if (!input) return;\r\n      // Save current state of the input\r\n      const { value, selectionStart, selectionEnd } = input;\r\n\r\n      this._recordChange({\r\n        value,\r\n        selectionStart,\r\n        selectionEnd,\r\n      });\r\n    },\r\n    _getLines(text: string, position: number): Array<string> {\r\n      return text.substring(0, position).split('\\n');\r\n    },\r\n    _recordStateIfChange(): void {\r\n      if (this.history.stack[this.history.offset].value != this.codeData) {\r\n        this._recordChange({\r\n          value: this.codeData,\r\n          selectionStart: this.codeData.length,\r\n          selectionEnd: this.codeData.length,\r\n        });\r\n      }\r\n    },\r\n    _applyEdits(record: Record): void {\r\n      // Save last selection state\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n      const last = this.history.stack[this.history.offset];\r\n\r\n      if (last && input) {\r\n        this.history.stack[this.history.offset] = {\r\n          ...last,\r\n          selectionStart: input.selectionStart,\r\n          selectionEnd: input.selectionEnd,\r\n        };\r\n      }\r\n\r\n      // Save the changes\r\n      this._recordChange(record);\r\n      this._updateInput(record);\r\n    },\r\n    _recordChange(record: Record, overwrite = false): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      if (stack.length && offset > -1) {\r\n        // When something updates, drop the redo operations\r\n        this.history.stack = stack.slice(0, offset + 1);\r\n\r\n        // Limit the number of operations to 100\r\n        const count = this.history.stack.length;\r\n\r\n        if (count > HISTORY_LIMIT) {\r\n          const extras = count - HISTORY_LIMIT;\r\n\r\n          this.history.stack = stack.slice(extras, count);\r\n          this.history.offset = Math.max(this.history.offset - extras, 0);\r\n        }\r\n      }\r\n\r\n      const timestamp = Date.now();\r\n\r\n      if (overwrite) {\r\n        const last = this.history.stack[this.history.offset];\r\n\r\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\r\n          // A previous entry exists and was in short interval\r\n\r\n          // Match the last word in the line\r\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\r\n\r\n          // Get the previous line\r\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\r\n\r\n          // Get the current line\r\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\r\n\r\n          if (previous && current && current[1].startsWith(previous[1])) {\r\n            // The last word of the previous line and current line match\r\n            // Overwrite previous entry so that undo will remove whole word\r\n            this.history.stack[this.history.offset] = {\r\n              ...record,\r\n              timestamp,\r\n            };\r\n\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add the new operation to the stack\r\n      this.history.stack.push({ ...record, timestamp });\r\n      this.history.offset++;\r\n    },\r\n\r\n    _updateInput(record: Record): void {\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n\r\n      if (!input) return;\r\n\r\n      // Update values and selection state\r\n      input.value = record.value;\r\n      input.selectionStart = record.selectionStart;\r\n      input.selectionEnd = record.selectionEnd;\r\n\r\n      this.$emit('input', record.value);\r\n      // this.props.onValueChange(record.value);\r\n    },\r\n    handleChange(e: KeyboardEvent): void {\r\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\r\n\r\n      this._recordChange(\r\n        {\r\n          value,\r\n          selectionStart,\r\n          selectionEnd,\r\n        },\r\n        true\r\n      );\r\n      this.$emit('input', value);\r\n      // this.props.onValueChange(value);\r\n    },\r\n    _undoEdit(): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      // Get the previous edit\r\n      const record = stack[offset - 1];\r\n\r\n      if (record) {\r\n        // Apply the changes and update the offset\r\n        this._updateInput(record);\r\n        this.history.offset = Math.max(offset - 1, 0);\r\n      }\r\n    },\r\n    _redoEdit(): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      // Get the next edit\r\n      const record = stack[offset + 1];\r\n\r\n      if (record) {\r\n        // Apply the changes and update the offset\r\n        this._updateInput(record);\r\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\r\n      }\r\n    },\r\n    handleKeyDown(e: KeyboardEvent): void {\r\n      // console.log(navigator.platform);\r\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\r\n\r\n      if (this.$listeners.keydown) {\r\n        // onKeyDown(e);\r\n        this.$emit('keydown', e);\r\n\r\n        if (e.defaultPrevented) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (e.keyCode === KEYCODE_ESCAPE) {\r\n        (<HTMLTextAreaElement>e.target).blur();\r\n        this.$emit('blur', e);\r\n      }\r\n\r\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\r\n\r\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\r\n\r\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\r\n        // Prevent focus change\r\n        e.preventDefault();\r\n\r\n        if (e.shiftKey) {\r\n          // Unindent selected lines\r\n          const linesBeforeCaret = this._getLines(value, selectionStart);\r\n          const startLine = linesBeforeCaret.length - 1;\r\n          const endLine = this._getLines(value, selectionEnd).length - 1;\r\n          const nextValue = value\r\n            .split('\\n')\r\n            .map((line, i) => {\r\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\r\n                return line.substring(tabCharacter.length);\r\n              }\r\n\r\n              return line;\r\n            })\r\n            .join('\\n');\r\n\r\n          if (value !== nextValue) {\r\n            const startLineText = linesBeforeCaret[startLine];\r\n\r\n            this._applyEdits({\r\n              value: nextValue,\r\n              // Move the start cursor if first line in selection was modified\r\n              // It was modified only if it started with a tab\r\n              selectionStart: startLineText.startsWith(tabCharacter)\r\n                ? selectionStart - tabCharacter.length\r\n                : selectionStart,\r\n              // Move the end cursor by total number of characters removed\r\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\r\n            });\r\n          }\r\n        } else if (selectionStart !== selectionEnd) {\r\n          // Indent selected lines\r\n          const linesBeforeCaret = this._getLines(value, selectionStart);\r\n          const startLine = linesBeforeCaret.length - 1;\r\n          const endLine = this._getLines(value, selectionEnd).length - 1;\r\n          const startLineText = linesBeforeCaret[startLine];\r\n\r\n          this._applyEdits({\r\n            value: value\r\n              .split('\\n')\r\n              .map((line, i) => {\r\n                if (i >= startLine && i <= endLine) {\r\n                  return tabCharacter + line;\r\n                }\r\n\r\n                return line;\r\n              })\r\n              .join('\\n'),\r\n            // Move the start cursor by number of characters added in first line of selection\r\n            // Don't move it if it there was no text before cursor\r\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\r\n            // Move the end cursor by total number of characters added\r\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\r\n          });\r\n        } else {\r\n          const updatedSelection = selectionStart + tabCharacter.length;\r\n\r\n          this._applyEdits({\r\n            // Insert tab character at caret\r\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: updatedSelection,\r\n            selectionEnd: updatedSelection,\r\n          });\r\n        }\r\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\r\n        const hasSelection = selectionStart !== selectionEnd;\r\n        const textBeforeCaret = value.substring(0, selectionStart);\r\n\r\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\r\n          // Prevent default delete behaviour\r\n          e.preventDefault();\r\n\r\n          const updatedSelection = selectionStart - tabCharacter.length;\r\n\r\n          this._applyEdits({\r\n            // Remove tab character at caret\r\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: updatedSelection,\r\n            selectionEnd: updatedSelection,\r\n          });\r\n        }\r\n      } else if (e.keyCode === KEYCODE_ENTER) {\r\n        // Ignore selections\r\n        if (selectionStart === selectionEnd) {\r\n          // Get the current line\r\n          const line = this._getLines(value, selectionStart).pop();\r\n          const matches = line?.match(/^\\s+/);\r\n\r\n          if (matches && matches[0]) {\r\n            e.preventDefault();\r\n\r\n            // Preserve indentation on inserting a new line\r\n            const indent = '\\n' + matches[0];\r\n            const updatedSelection = selectionStart + indent.length;\r\n\r\n            this._applyEdits({\r\n              // Insert indentation character at caret\r\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\r\n              // Update caret position\r\n              selectionStart: updatedSelection,\r\n              selectionEnd: updatedSelection,\r\n            });\r\n          }\r\n        }\r\n      } else if (BRACKET_PAIRS[e.key]) {\r\n        // If text is selected, wrap them in the characters\r\n        if (selectionStart !== selectionEnd) {\r\n          e.preventDefault();\r\n\r\n          this._applyEdits({\r\n            value:\r\n              value.substring(0, selectionStart) +\r\n              e.key +\r\n              value.substring(selectionStart, selectionEnd) +\r\n              BRACKET_PAIRS[e.key] +\r\n              value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: selectionStart + 1,\r\n            selectionEnd: selectionEnd + 1,\r\n          });\r\n        }\r\n      } else if (\r\n        (isMacLike\r\n          ? // Trigger undo with ⌘+Z on Mac\r\n            e.metaKey && e.keyCode === KEYCODE_Z\r\n          : // Trigger undo with Ctrl+Z on other platforms\r\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\r\n        !e.shiftKey &&\r\n        !e.altKey\r\n      ) {\r\n        e.preventDefault();\r\n\r\n        this._undoEdit();\r\n      } else if (\r\n        (isMacLike\r\n          ? // Trigger redo with ⌘+Shift+Z on Mac\r\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\r\n          : isWindows\r\n          ? // Trigger redo with Ctrl+Y on Windows\r\n            e.ctrlKey && e.keyCode === KEYCODE_Y\r\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\r\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\r\n        !e.altKey\r\n      ) {\r\n        e.preventDefault();\r\n\r\n        this._redoEdit();\r\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\r\n        e.preventDefault();\r\n\r\n        // Toggle capturing tab key so users can focus away\r\n        this.capture = !this.capture;\r\n      }\r\n    },\r\n  },\r\n  render(h): VNode {\r\n    const lineNumberWidthCalculator = h(\r\n      'div',\r\n      {\r\n        attrs: {\r\n          class: 'prism-editor__line-width-calc',\r\n          style: 'height: 0px; visibility: hidden; pointer-events: none;',\r\n        },\r\n      },\r\n      '999'\r\n    );\r\n    const lineNumbers = h(\r\n      'div',\r\n      {\r\n        staticClass: 'prism-editor__line-numbers',\r\n        style: {\r\n          'min-height': this.lineNumbersHeight,\r\n        },\r\n        attrs: {\r\n          'aria-hidden': 'true',\r\n        },\r\n      },\r\n      [\r\n        lineNumberWidthCalculator,\r\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\r\n          return h('div', { attrs: { class: 'prism-editor__line-number token comment' } }, `${++index}`);\r\n        }),\r\n      ]\r\n    );\r\n\r\n    const textarea = h('textarea', {\r\n      ref: 'textarea',\r\n      on: {\r\n        input: this.handleChange,\r\n        keydown: this.handleKeyDown,\r\n        click: ($event: MouseEvent) => {\r\n          this.$emit('click', $event);\r\n        },\r\n        keyup: ($event: KeyboardEvent) => {\r\n          this.$emit('keyup', $event);\r\n        },\r\n        focus: ($event: FocusEvent) => {\r\n          this._recordStateIfChange();\r\n          this.$emit('focus', $event);\r\n        },\r\n        blur: ($event: FocusEvent) => {\r\n          this.$emit('blur', $event);\r\n        },\r\n      },\r\n      staticClass: 'prism-editor__textarea',\r\n      class: {\r\n        'prism-editor__textarea--empty': this.isEmpty,\r\n      },\r\n      attrs: {\r\n        spellCheck: 'false',\r\n        autocapitalize: 'off',\r\n        autocomplete: 'off',\r\n        autocorrect: 'off',\r\n        'data-gramm': 'false',\r\n        placeholder: this.placeholder,\r\n        'data-testid': 'textarea',\r\n        readonly: this.readonly,\r\n      },\r\n      domProps: {\r\n        value: this.codeData,\r\n      },\r\n    });\r\n    const preview = h('pre', {\r\n      ref: 'pre',\r\n      staticClass: 'prism-editor__editor',\r\n      attrs: {\r\n        'data-testid': 'preview',\r\n      },\r\n      domProps: {\r\n        innerHTML: this.content,\r\n      },\r\n    });\r\n    const editorContainer = h('div', { staticClass: 'prism-editor__container' }, [textarea, preview]);\r\n    return h('div', { staticClass: 'prism-editor-wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\r\n  },\r\n});\r\n"],"names":["BRACKET_PAIRS","isWindows","global","test","navigator","platform","isMacLike","PrismEditor","Vue","extend","props","lineNumbers","type","Boolean","autoStyleLineNumbers","readonly","value","String","highlight","Function","required","tabSize","Number","insertSpaces","ignoreTabKey","placeholder","data","capture","history","stack","offset","lineNumbersHeight","codeData","watch","immediate","handler","newVal","content","this","$nextTick","_this","setLineNumbersHeight","_this2","styleLineNumbers","computed","isEmpty","length","lineNumbersCount","split","mounted","_recordCurrentState","methods","getComputedStyle","$refs","pre","height","$editor","$lineNumbers","$el","querySelector","editorStyles","window","btlr","bblr","style","forEach","input","textarea","_recordChange","selectionStart","selectionEnd","_getLines","text","position","substring","_recordStateIfChange","_applyEdits","record","last","_updateInput","overwrite","slice","count","extras","Math","max","timestamp","Date","now","re","previous","pop","_this$_getLines$pop","match","current","_this$_getLines$pop2","startsWith","push","$emit","handleChange","e","target","_undoEdit","_redoEdit","min","handleKeyDown","$listeners","keydown","defaultPrevented","keyCode","blur","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","updatedSelection","hasSelection","endsWith","matches","indent","key","metaKey","ctrlKey","altKey","render","h","lineNumberWidthCalculator","attrs","staticClass","Array","from","keys","_","index","ref","on","click","$event","_this3","keyup","focus","spellCheck","autocapitalize","autocomplete","autocorrect","domProps","preview","innerHTML","editorContainer"],"mappings":"6hBAGA,IAQMA,EAA6C,KAC7C,QACA,QACA,QACA,QACA,KAMAC,EAAY,cAAeC,UAAiBC,KAAKC,UAAUC,UAC3DC,EAAY,cAAeJ,6BAAoCC,KAAKC,UAAUC,UAwBvEE,EAAcC,EAAIC,OAAO,CACpCC,MAAO,CACLC,YAAa,CACXC,KAAMC,iBACG,GAEXC,qBAAsB,CACpBF,KAAMC,iBACG,GAEXE,SAAU,CACRH,KAAMC,iBACG,GAEXG,MAAO,CACLJ,KAAMK,eACG,IAEXC,UAAW,CACTN,KAAMO,SACNC,UAAU,GAEZC,QAAS,CACPT,KAAMU,eACG,GAEXC,aAAc,CACZX,KAAMC,iBACG,GAEXW,aAAc,CACZZ,KAAMC,iBACG,GAEXY,YAAa,CACXb,KAAMK,eACG,KAGbS,sBACS,CACLC,SAAS,EACTC,QAAS,CACPC,MAAO,GACPC,QAAS,GAEXC,kBAAmB,OACnBC,SAAU,KAGdC,MAAO,CACLjB,MAAO,CACLkB,WAAW,EACXC,iBAAQC,QAICJ,SAHFI,GACa,KAMtBC,QAAS,CACPH,WAAW,EACXC,8BACMG,KAAK3B,kBACF4B,WAAU,WACbC,EAAKC,4BAKb9B,uCACO4B,WAAU,WACbG,EAAKC,mBACLD,EAAKD,4BAIXG,SAAU,CACRC,0BACkC,IAAzBP,KAAKN,SAASc,QAEvBT,0BACiBC,KAAKpB,UAAUoB,KAAKN,UAAY,UAIjDe,mCACqBT,KAAKN,SAASgB,MAAM,WAAWF,SAItDG,wBACOC,2BACAP,oBAGPQ,QAAS,CACPV,qCACOV,kBAAoBqB,iBAAiBd,KAAKe,MAAMC,KAA4BC,QAEnFZ,+BACOL,KAAK3B,aAAgB2B,KAAKxB,0BAEzB0C,EAAUlB,KAAKe,MAAMC,IACrBG,EAAsCnB,KAAKoB,IAAIC,cAAc,+BAC7DC,EAAeC,OAAOT,iBAAiBI,QAExCjB,WAAU,eACPuB,EAAY,yBACZC,EAAY,4BACbN,IACLA,EAAaO,MAAMF,GAAQF,EAAaE,GACxCL,EAAaO,MAAMD,GAAQH,EAAaG,GACxCP,EAAQQ,MAAMF,GAAQ,IACtBN,EAAQQ,MAAMD,GAAQ,IAEH,CAAC,mBAAoB,aAAc,cAAe,cAAe,YAAa,eACtFE,SAAQ,SAACD,GAClBP,EAAaO,MAAMA,GAASJ,EAAaI,MAE3CP,EAAaO,MAAM,iBAA0B,IAAMJ,EAAa,qBAGpEV,mCACQgB,EAAQ5B,KAAKe,MAAMc,SAEpBD,QAIAE,cAAc,CACjBpD,MAH8CkD,EAAxClD,MAINqD,eAJ8CH,EAAjCG,eAKbC,aAL8CJ,EAAjBI,gBAQjCC,mBAAUC,EAAcC,UACfD,EAAKE,UAAU,EAAGD,GAAUzB,MAAM,OAE3C2B,gCACMrC,KAAKV,QAAQC,MAAMS,KAAKV,QAAQE,QAAQd,OAASsB,KAAKN,eACnDoC,cAAc,CACjBpD,MAAOsB,KAAKN,SACZqC,eAAgB/B,KAAKN,SAASc,OAC9BwB,aAAchC,KAAKN,SAASc,UAIlC8B,qBAAYC,OAEJX,EAAQ5B,KAAKe,MAAMc,SACnBW,EAAOxC,KAAKV,QAAQC,MAAMS,KAAKV,QAAQE,QAEzCgD,GAAQZ,SACLtC,QAAQC,MAAMS,KAAKV,QAAQE,aAC3BgD,GACHT,eAAgBH,EAAMG,eACtBC,aAAcJ,EAAMI,qBAKnBF,cAAcS,QACdE,aAAaF,IAEpBT,uBAAcS,EAAgBG,YAAAA,IAAAA,GAAY,SACd1C,KAAKV,QAAvBC,IAAAA,MAAOC,IAAAA,UAEXD,EAAMiB,QAAUhB,GAAU,EAAG,MAE1BF,QAAQC,MAAQA,EAAMoD,MAAM,EAAGnD,EAAS,OAGvCoD,EAAQ5C,KAAKV,QAAQC,MAAMiB,UAE7BoC,EA5MU,IA4Ma,KACnBC,EAASD,EA7MH,SA+MPtD,QAAQC,MAAQA,EAAMoD,MAAME,EAAQD,QACpCtD,QAAQE,OAASsD,KAAKC,IAAI/C,KAAKV,QAAQE,OAASqD,EAAQ,QAI3DG,EAAYC,KAAKC,SAEnBR,EAAW,KACPF,EAAOxC,KAAKV,QAAQC,MAAMS,KAAKV,QAAQE,WAEzCgD,GAAQQ,EAAYR,EAAKQ,UAxNZ,IAwN0C,SAInDG,EAAK,yBAGLC,YAAWpD,KAAKiC,UAAUO,EAAK9D,MAAO8D,EAAKT,gBAAgBsB,0BAAhDC,EAAuDC,MAAMJ,GAGxEK,YAAUxD,KAAKiC,UAAUM,EAAO7D,MAAO6D,EAAOR,gBAAgBsB,0BAApDI,EAA2DF,MAAMJ,MAE7EC,GAAYI,GAAWA,EAAQ,GAAGE,WAAWN,EAAS,qBAGnD9D,QAAQC,MAAMS,KAAKV,QAAQE,aAC3B+C,GACHS,UAAAA,WASH1D,QAAQC,MAAMoE,UAAUpB,GAAQS,UAAAA,UAChC1D,QAAQE,UAGfiD,sBAAaF,OACLX,EAAQ5B,KAAKe,MAAMc,SAEpBD,IAGLA,EAAMlD,MAAQ6D,EAAO7D,MACrBkD,EAAMG,eAAiBQ,EAAOR,eAC9BH,EAAMI,aAAeO,EAAOP,kBAEvB4B,MAAM,QAASrB,EAAO7D,SAG7BmF,sBAAaC,SACqCA,EAAEC,OAA1CrF,IAAAA,WAEHoD,cACH,CACEpD,MAAAA,EACAqD,iBALWA,eAMXC,eAN2BA,eAQ7B,QAEG4B,MAAM,QAASlF,IAGtBsF,2BAC4BhE,KAAKV,QAAhBE,IAAAA,OAGT+C,IAHEhD,MAGaC,EAAS,GAE1B+C,SAEGE,aAAaF,QACbjD,QAAQE,OAASsD,KAAKC,IAAIvD,EAAS,EAAG,KAG/CyE,2BAC4BjE,KAAKV,QAAvBC,IAAAA,MAAOC,IAAAA,OAGT+C,EAAShD,EAAMC,EAAS,GAE1B+C,SAEGE,aAAaF,QACbjD,QAAQE,OAASsD,KAAKoB,IAAI1E,EAAS,EAAGD,EAAMiB,OAAS,KAG9D2D,uBAAcL,OAEJ/E,EAAwCiB,KAAxCjB,QAASE,EAA+Be,KAA/Bf,aAAcC,EAAiBc,KAAjBd,iBAE3Bc,KAAKoE,WAAWC,eAEbT,MAAM,UAAWE,IAElBA,EAAEQ,mBA5TS,KAiUbR,EAAES,UACkBT,EAAEC,OAAQS,YAC3BZ,MAAM,OAAQE,UAG2BA,EAAEC,OAA1CrF,IAAAA,MAAOqD,IAAAA,eAAgBC,IAAAA,aAEzByC,GAAgBxF,EAAe,IAAM,MAAMyF,OAAO3F,MA7U1C,IA+UV+E,EAAES,UAA4BrF,GAAgBc,KAAKX,WAErDyE,EAAEa,iBAEEb,EAAEc,SAAU,KAERC,EAAmB7E,KAAKiC,UAAUvD,EAAOqD,GACzC+C,EAAYD,EAAiBrE,OAAS,EACtCuE,EAAU/E,KAAKiC,UAAUvD,EAAOsD,GAAcxB,OAAS,EACvDwE,EAAYtG,EACfgC,MAAM,MACNuE,KAAI,SAACC,EAAMC,UACNA,GAAKL,GAAaK,GAAKJ,GAAWG,EAAKxB,WAAWe,GAC7CS,EAAK9C,UAAUqC,EAAajE,QAG9B0E,KAERE,KAAK,MAEJ1G,IAAUsG,QAGP1C,YAAY,CACf5D,MAAOsG,EAGPjD,eANoB8C,EAAiBC,GAMPpB,WAAWe,GACrC1C,EAAiB0C,EAAajE,OAC9BuB,EAEJC,aAAcA,GAAgBtD,EAAM8B,OAASwE,EAAUxE,eAGtD,GAAIuB,IAAmBC,EAAc,KAEpC6C,EAAmB7E,KAAKiC,UAAUvD,EAAOqD,GACzC+C,EAAYD,EAAiBrE,OAAS,EACtCuE,EAAU/E,KAAKiC,UAAUvD,EAAOsD,GAAcxB,OAAS,EACvD6E,EAAgBR,EAAiBC,QAElCxC,YAAY,CACf5D,MAAOA,EACJgC,MAAM,MACNuE,KAAI,SAACC,EAAMC,UACNA,GAAKL,GAAaK,GAAKJ,EAClBN,EAAeS,EAGjBA,KAERE,KAAK,MAGRrD,eAAgB,KAAKlE,KAAKwH,GAAiBtD,EAAiB0C,EAAajE,OAASuB,EAElFC,aAAcA,EAAeyC,EAAajE,QAAUuE,EAAUD,EAAY,SAEvE,KACCQ,EAAmBvD,EAAiB0C,EAAajE,YAElD8B,YAAY,CAEf5D,MAAOA,EAAM0D,UAAU,EAAGL,GAAkB0C,EAAe/F,EAAM0D,UAAUJ,GAE3ED,eAAgBuD,EAChBtD,aAAcsD,SAGb,GAnZa,IAmZTxB,EAAES,QAA+B,KACpCgB,EAAexD,IAAmBC,KAChBtD,EAAM0D,UAAU,EAAGL,GAEvByD,SAASf,KAAkBc,EAAc,CAE3DzB,EAAEa,qBAEIW,EAAmBvD,EAAiB0C,EAAajE,YAElD8B,YAAY,CAEf5D,MAAOA,EAAM0D,UAAU,EAAGL,EAAiB0C,EAAajE,QAAU9B,EAAM0D,UAAUJ,GAElFD,eAAgBuD,EAChBtD,aAAcsD,UAGb,GAvaS,KAuaLxB,EAAES,YAEPxC,IAAmBC,EAAc,KAE7BkD,EAAOlF,KAAKiC,UAAUvD,EAAOqD,GAAgBsB,MAC7CoC,EAAUP,MAAAA,SAAAA,EAAM3B,MAAM,WAExBkC,GAAWA,EAAQ,GAAI,CACzB3B,EAAEa,qBAGIe,EAAS,KAAOD,EAAQ,GACxBH,EAAmBvD,EAAiB2D,EAAOlF,YAE5C8B,YAAY,CAEf5D,MAAOA,EAAM0D,UAAU,EAAGL,GAAkB2D,EAAShH,EAAM0D,UAAUJ,GAErED,eAAgBuD,EAChBtD,aAAcsD,WAIX5H,EAAcoG,EAAE6B,KAErB5D,IAAmBC,IACrB8B,EAAEa,sBAEGrC,YAAY,CACf5D,MACEA,EAAM0D,UAAU,EAAGL,GACnB+B,EAAE6B,IACFjH,EAAM0D,UAAUL,EAAgBC,GAChCtE,EAAcoG,EAAE6B,KAChBjH,EAAM0D,UAAUJ,GAElBD,eAAgBA,EAAiB,EACjCC,aAAcA,EAAe,OAIhChE,EAEG8F,EAAE8B,SA9cI,KA8cO9B,EAAES,QAEfT,EAAE+B,SAhdI,KAgdO/B,EAAES,UAClBT,EAAEc,UACFd,EAAEgC,QAMF9H,EAEG8F,EAAE8B,SA1dI,KA0dO9B,EAAES,SAAyBT,EAAEc,SAC1CjH,EAEAmG,EAAE+B,SA9dI,KA8dO/B,EAAES,QAEfT,EAAE+B,SA/dI,KA+dO/B,EAAES,SAAyBT,EAAEc,YAC7Cd,EAAEgC,QAEHhC,EAAEa,sBAEGV,aAneK,KAoeDH,EAAES,UAAyBT,EAAE+B,SAAY7H,IAAY8F,EAAEc,WAChEd,EAAEa,sBAGGtF,SAAWW,KAAKX,UArBrByE,EAAEa,sBAEGX,gBAuBX+B,gBAAOC,cACCC,EAA4BD,EAChC,MACA,CACEE,MAAO,OACE,gCACPxE,MAAO,2DAGX,OAEIrD,EAAc2H,EAClB,MACA,CACEG,YAAa,6BACbzE,MAAO,cACS1B,KAAKP,mBAErByG,MAAO,eACU,SAGnB,CACED,EACAG,MAAMC,KAAKD,MAAMpG,KAAKS,kBAAkB6F,QAAQrB,KAAI,SAACsB,EAAGC,UAC/CR,EAAE,MAAO,CAAEE,MAAO,OAAS,kDAAoDM,QAKtF3E,EAAWmE,EAAE,WAAY,CAC7BS,IAAK,WACLC,GAAI,CACF9E,MAAO5B,KAAK6D,aACZQ,QAASrE,KAAKmE,cACdwC,MAAO,SAACC,GACNC,EAAKjD,MAAM,QAASgD,IAEtBE,MAAO,SAACF,GACNC,EAAKjD,MAAM,QAASgD,IAEtBG,MAAO,SAACH,GACNC,EAAKxE,uBACLwE,EAAKjD,MAAM,QAASgD,IAEtBpC,KAAM,SAACoC,GACLC,EAAKjD,MAAM,OAAQgD,KAGvBT,YAAa,+BACN,iCAC4BnG,KAAKO,SAExC2F,MAAO,CACLc,WAAY,QACZC,eAAgB,MAChBC,aAAc,MACdC,YAAa,mBACC,QACdhI,YAAaa,KAAKb,0BACH,WACfV,SAAUuB,KAAKvB,UAEjB2I,SAAU,CACR1I,MAAOsB,KAAKN,YAGV2H,EAAUrB,EAAE,MAAO,CACvBS,IAAK,MACLN,YAAa,uBACbD,MAAO,eACU,WAEjBkB,SAAU,CACRE,UAAWtH,KAAKD,WAGdwH,EAAkBvB,EAAE,MAAO,CAAEG,YAAa,2BAA6B,CAACtE,EAAUwF,WACjFrB,EAAE,MAAO,CAAEG,YAAa,wBAA0B,CAACnG,KAAK3B,aAAeA,EAAakJ"}