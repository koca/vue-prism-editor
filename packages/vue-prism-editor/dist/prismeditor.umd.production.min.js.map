{"version":3,"file":"prismeditor.umd.production.min.js","sources":["../src/Editor.ts"],"sourcesContent":["import Vue, { VNode } from 'vue';\r\n\r\nimport './styles.css';\r\nconst KEYCODE_ENTER = 13;\r\nconst KEYCODE_TAB = 9;\r\nconst KEYCODE_BACKSPACE = 8;\r\nconst KEYCODE_Y = 89;\r\nconst KEYCODE_Z = 90;\r\nconst KEYCODE_M = 77;\r\nconst KEYCODE_ESCAPE = 27;\r\n\r\nconst BRACKET_PAIRS: {[opening: string]: string} = {\r\n  '(':')',\r\n  '{':'}',\r\n  '[':']',\r\n  '\"':'\"',\r\n  \"'\":\"'\",\r\n};\r\n\r\nconst HISTORY_LIMIT = 100;\r\nconst HISTORY_TIME_GAP = 3000;\r\n\r\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\r\nconst isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n\r\nexport interface EditorProps {\r\n  lineNumbers: boolean;\r\n  autoStyleLineNumbers: boolean;\r\n  readonly: boolean;\r\n  value: string;\r\n  highlight: () => string;\r\n  tabSize: number;\r\n  insertSpaces: boolean;\r\n  ignoreTabKey: boolean;\r\n  placeholder: string;\r\n}\r\nexport interface Record {\r\n  value: string;\r\n  selectionStart: number;\r\n  selectionEnd: number;\r\n}\r\n\r\nexport interface History {\r\n  stack: Array<Record & { timestamp: number }>;\r\n  offset: number;\r\n}\r\ninterface AutocompleteEntry {\r\n  text: string\r\n  overlap: number\r\n  label?: string\r\n}\r\n\r\nexport const PrismEditor = Vue.extend({\r\n  props: {\r\n    lineNumbers: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    autoStyleLineNumbers: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    readonly: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    value: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n    highlight: {\r\n      type: Function,\r\n      required: true,\r\n    },\r\n    tabSize: {\r\n      type: Number,\r\n      default: 2,\r\n    },\r\n    insertSpaces: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    ignoreTabKey: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    placeholder: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n    autocomplete: {\r\n      type: Function,\r\n      default() {\r\n        return []\r\n      }\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      capture: true,\r\n      history: {\r\n        stack: [],\r\n        offset: -1,\r\n      } as History,\r\n      lineNumbersHeight: '20px',\r\n      codeData: '',\r\n\r\n      autocompleteOpen: false,\r\n      autocompleteIndex: 0,\r\n      autocompleteData: [] as AutocompleteEntry[]\r\n    };\r\n  },\r\n  watch: {\r\n    value: {\r\n      immediate: true,\r\n      handler(newVal: string): void {\r\n        if (!newVal) {\r\n          this.codeData = '';\r\n        } else {\r\n          this.codeData = newVal;\r\n        }\r\n      },\r\n    },\r\n    content: {\r\n      immediate: true,\r\n      handler(): void {\r\n        if (this.lineNumbers) {\r\n          this.$nextTick(() => {\r\n            this.setLineNumbersHeight();\r\n          });\r\n        }\r\n      },\r\n    },\r\n    lineNumbers(): void {\r\n      this.$nextTick(() => {\r\n        this.styleLineNumbers();\r\n        this.setLineNumbersHeight();\r\n      });\r\n    },\r\n    autocompleteIndex() {\r\n      Vue.nextTick(() => {\r\n        let node = this.$el.querySelector('ul.prism-editor__autocomplete > li.selected');\r\n        if (node) node.scrollIntoView({block: 'nearest'});\r\n      })\r\n    },\r\n  },\r\n  computed: {\r\n    isEmpty(): boolean {\r\n      return this.codeData.length === 0;\r\n    },\r\n    content(): string {\r\n      const result = this.highlight(this.codeData) + '<br />';\r\n      // todo: VNode support?\r\n      return result;\r\n    },\r\n    lineNumbersCount(): number {\r\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\r\n      return totalLines;\r\n    },\r\n    cursorOffset() {\r\n      let text: string = this.codeData;\r\n      let input = this.$refs.textarea as HTMLTextAreaElement;\r\n      let wrapper = this.$refs.wrapper as HTMLDivElement;\r\n      let lines = text.substring(0, input.selectionEnd || 0).split(/\\r\\n|\\n/);\r\n      let font_size = parseFloat(getComputedStyle(input).getPropertyValue('font-size'));\r\n      let line = lines.length;\r\n      let column = lines[lines.length-1].length;\r\n      return [\r\n        Math.min((column * 8.85 * (font_size / 16))    - wrapper.scrollLeft, wrapper.clientWidth - Math.min(240, wrapper.clientWidth)),\r\n        (line * 24.0 * (font_size / 16)) + 2  - wrapper.scrollTop,\r\n      ]\r\n    },\r\n  },\r\n  mounted() {\r\n    this._recordCurrentState();\r\n    this.styleLineNumbers();\r\n  },\r\n\r\n  methods: {\r\n    updateAutocompleteData() {\r\n      let input = this.$refs.textarea as HTMLTextAreaElement;\r\n      let data: AutocompleteEntry[] = typeof this.autocomplete == 'function' ? this.autocomplete(this.codeData, input.selectionEnd) : [];\r\n      let old_length = this.autocompleteData.length;\r\n      this.autocompleteData.splice(0, Infinity, ...data);\r\n      this.autocompleteOpen = true;\r\n      this.autocompleteIndex = Math.max(0, Math.min(this.autocompleteIndex, this.autocompleteData.length-1));\r\n      if (old_length > this.autocompleteData.length) this.autocompleteIndex = 0;\r\n    },\r\n    acceptAutocomplete(event: Event, option?: number) {\r\n      event.preventDefault()\r\n      if (option == undefined) option = this.autocompleteIndex;\r\n\r\n      let input = this.$refs.textarea as HTMLTextAreaElement;\r\n      let wrapper = this.$refs.wrapper as HTMLDivElement;\r\n      let suggestion = this.autocompleteData[option] || this.autocompleteData[0];\r\n      if (!suggestion) return;\r\n      \r\n      let overlap = suggestion.overlap || 0;\r\n      let new_text = [\r\n        this.codeData.substr(0, input.selectionEnd - overlap),\r\n        suggestion.text,\r\n        this.codeData.substring(input.selectionEnd),\r\n      ]\r\n      let result: string = new_text.join('');\r\n      let cursor_pos = input.selectionEnd - overlap + suggestion.text.length + (suggestion.text.endsWith(')') ? -1 : 0);\r\n      input.selectionStart = input.selectionEnd = cursor_pos;\r\n\r\n      this._applyEdits({\r\n        value: result,\r\n        selectionStart: cursor_pos,\r\n        selectionEnd: cursor_pos,\r\n      });\r\n      let inserted_characters = suggestion.text.length - suggestion.overlap;\r\n      Vue.nextTick(() => {\r\n        wrapper.scrollLeft += inserted_characters * 8.85;\r\n      })\r\n\r\n      if (suggestion.text.endsWith('.')) {\r\n        setTimeout(() => {\r\n          this.updateAutocompleteData();\r\n        }, 1);\r\n      } else {\r\n        this.autocompleteOpen = false;\r\n      }\r\n    },\r\n    setLineNumbersHeight(): void {\r\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\r\n    },\r\n    styleLineNumbers(): void {\r\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\r\n\r\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\r\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\r\n      const editorStyles = window.getComputedStyle($editor);\r\n\r\n      this.$nextTick(() => {\r\n        const btlr: any = 'border-top-left-radius';\r\n        const bblr: any = 'border-bottom-left-radius';\r\n        if (!$lineNumbers) return;\r\n        $lineNumbers.style[btlr] = editorStyles[btlr];\r\n        $lineNumbers.style[bblr] = editorStyles[bblr];\r\n        $editor.style[btlr] = '0';\r\n        $editor.style[bblr] = '0';\r\n\r\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\r\n        stylesList.forEach((style: any) => {\r\n          $lineNumbers.style[style] = editorStyles[style];\r\n        });\r\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\r\n      });\r\n    },\r\n    _recordCurrentState(): void {\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n\r\n      if (!input) return;\r\n      // Save current state of the input\r\n      const { value, selectionStart, selectionEnd } = input;\r\n\r\n      this._recordChange({\r\n        value,\r\n        selectionStart,\r\n        selectionEnd,\r\n      });\r\n    },\r\n    _getLines(text: string, position: number): Array<string> {\r\n      return text.substring(0, position).split('\\n');\r\n    },\r\n    _recordStateIfChange(): void {\r\n      if (this.history.stack[this.history.offset].value != this.codeData) {\r\n        this._recordChange({\r\n          value: this.codeData,\r\n          selectionStart: this.codeData.length,\r\n          selectionEnd: this.codeData.length,\r\n        });\r\n      }\r\n    },\r\n    _applyEdits(record: Record): void {\r\n      // Save last selection state\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n      const last = this.history.stack[this.history.offset];\r\n\r\n      if (last && input) {\r\n        this.history.stack[this.history.offset] = {\r\n          ...last,\r\n          selectionStart: input.selectionStart,\r\n          selectionEnd: input.selectionEnd,\r\n        };\r\n      }\r\n\r\n      // Save the changes\r\n      this._recordChange(record);\r\n      this._updateInput(record);\r\n    },\r\n    _recordChange(record: Record, overwrite = false): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      if (stack.length && offset > -1) {\r\n        // When something updates, drop the redo operations\r\n        this.history.stack = stack.slice(0, offset + 1);\r\n\r\n        // Limit the number of operations to 100\r\n        const count = this.history.stack.length;\r\n\r\n        if (count > HISTORY_LIMIT) {\r\n          const extras = count - HISTORY_LIMIT;\r\n\r\n          this.history.stack = stack.slice(extras, count);\r\n          this.history.offset = Math.max(this.history.offset - extras, 0);\r\n        }\r\n      }\r\n\r\n      const timestamp = Date.now();\r\n\r\n      if (overwrite) {\r\n        const last = this.history.stack[this.history.offset];\r\n\r\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\r\n          // A previous entry exists and was in short interval\r\n\r\n          // Match the last word in the line\r\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\r\n\r\n          // Get the previous line\r\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\r\n\r\n          // Get the current line\r\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\r\n\r\n          if (previous && current && current[1].startsWith(previous[1])) {\r\n            // The last word of the previous line and current line match\r\n            // Overwrite previous entry so that undo will remove whole word\r\n            this.history.stack[this.history.offset] = {\r\n              ...record,\r\n              timestamp,\r\n            };\r\n\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add the new operation to the stack\r\n      this.history.stack.push({ ...record, timestamp });\r\n      this.history.offset++;\r\n    },\r\n\r\n    _updateInput(record: Record): void {\r\n      const input = this.$refs.textarea as HTMLTextAreaElement;\r\n\r\n      if (!input) return;\r\n\r\n      // Update values and selection state\r\n      input.value = record.value;\r\n      input.selectionStart = record.selectionStart;\r\n      input.selectionEnd = record.selectionEnd;\r\n\r\n      this.$emit('input', record.value);\r\n      // this.props.onValueChange(record.value);\r\n    },\r\n    handleChange(e: KeyboardEvent): void {\r\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\r\n\r\n      this._recordChange(\r\n        {\r\n          value,\r\n          selectionStart,\r\n          selectionEnd,\r\n        },\r\n        true\r\n      );\r\n      this.$emit('input', value);\r\n      // this.props.onValueChange(value);\r\n    },\r\n    _undoEdit(): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      // Get the previous edit\r\n      const record = stack[offset - 1];\r\n\r\n      if (record) {\r\n        // Apply the changes and update the offset\r\n        this._updateInput(record);\r\n        this.history.offset = Math.max(offset - 1, 0);\r\n      }\r\n    },\r\n    _redoEdit(): void {\r\n      const { stack, offset } = this.history;\r\n\r\n      // Get the next edit\r\n      const record = stack[offset + 1];\r\n\r\n      if (record) {\r\n        // Apply the changes and update the offset\r\n        this._updateInput(record);\r\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\r\n      }\r\n    },\r\n    handleKeyDown(e: KeyboardEvent): void {\r\n      // console.log(navigator.platform);\r\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\r\n\r\n      if (this.$listeners.keydown) {\r\n        // onKeyDown(e);\r\n        this.$emit('keydown', e);\r\n\r\n        if (e.defaultPrevented) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (e.keyCode === 9 && this.autocompleteData.length && this.autocompleteOpen) {\r\n        this.acceptAutocomplete(e);\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        return;\r\n      }\r\n      if (e.keyCode === 27) {\r\n        // Escape\r\n        if (this.autocompleteData.length && this.autocompleteOpen) {\r\n          e.preventDefault();\r\n          this.autocompleteOpen = false;\r\n          return;\r\n        }\r\n      } else if (e.keyCode === 38) {\r\n        // Up\r\n        if (this.autocompleteData.length && this.autocompleteOpen) {\r\n          e.preventDefault();\r\n          this.autocompleteIndex = (this.autocompleteIndex ? this.autocompleteIndex : this.autocompleteData.length) - 1;\r\n          return;\r\n        }\r\n      } else if (e.keyCode === 40) {\r\n        // Down\r\n        if (this.autocompleteData.length && this.autocompleteOpen) {\r\n          e.preventDefault();\r\n          this.autocompleteIndex = (this.autocompleteIndex + 1) % this.autocompleteData.length;\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (e.keyCode === KEYCODE_ESCAPE) {\r\n        (<HTMLTextAreaElement>e.target).blur();\r\n        this.$emit('blur', e);\r\n      }\r\n\r\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\r\n\r\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\r\n\r\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\r\n        // Prevent focus change\r\n        e.preventDefault();\r\n\r\n        if (e.shiftKey) {\r\n          // Unindent selected lines\r\n          const linesBeforeCaret = this._getLines(value, selectionStart);\r\n          const startLine = linesBeforeCaret.length - 1;\r\n          const endLine = this._getLines(value, selectionEnd).length - 1;\r\n          const nextValue = value\r\n            .split('\\n')\r\n            .map((line, i) => {\r\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\r\n                return line.substring(tabCharacter.length);\r\n              }\r\n\r\n              return line;\r\n            })\r\n            .join('\\n');\r\n\r\n          if (value !== nextValue) {\r\n            const startLineText = linesBeforeCaret[startLine];\r\n\r\n            this._applyEdits({\r\n              value: nextValue,\r\n              // Move the start cursor if first line in selection was modified\r\n              // It was modified only if it started with a tab\r\n              selectionStart: startLineText.startsWith(tabCharacter)\r\n                ? selectionStart - tabCharacter.length\r\n                : selectionStart,\r\n              // Move the end cursor by total number of characters removed\r\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\r\n            });\r\n          }\r\n        } else if (selectionStart !== selectionEnd) {\r\n          // Indent selected lines\r\n          const linesBeforeCaret = this._getLines(value, selectionStart);\r\n          const startLine = linesBeforeCaret.length - 1;\r\n          const endLine = this._getLines(value, selectionEnd).length - 1;\r\n          const startLineText = linesBeforeCaret[startLine];\r\n\r\n          this._applyEdits({\r\n            value: value\r\n              .split('\\n')\r\n              .map((line, i) => {\r\n                if (i >= startLine && i <= endLine) {\r\n                  return tabCharacter + line;\r\n                }\r\n\r\n                return line;\r\n              })\r\n              .join('\\n'),\r\n            // Move the start cursor by number of characters added in first line of selection\r\n            // Don't move it if it there was no text before cursor\r\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\r\n            // Move the end cursor by total number of characters added\r\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\r\n          });\r\n        } else {\r\n          const updatedSelection = selectionStart + tabCharacter.length;\r\n\r\n          this._applyEdits({\r\n            // Insert tab character at caret\r\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: updatedSelection,\r\n            selectionEnd: updatedSelection,\r\n          });\r\n        }\r\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\r\n        const hasSelection = selectionStart !== selectionEnd;\r\n        const textBeforeCaret = value.substring(0, selectionStart);\r\n\r\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\r\n          // Prevent default delete behaviour\r\n          e.preventDefault();\r\n\r\n          const updatedSelection = selectionStart - tabCharacter.length;\r\n\r\n          this._applyEdits({\r\n            // Remove tab character at caret\r\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: updatedSelection,\r\n            selectionEnd: updatedSelection,\r\n          });\r\n        }\r\n      } else if (e.keyCode === KEYCODE_ENTER) {\r\n        \r\n        if (this.autocompleteData.length && this.autocompleteOpen) {\r\n          this.acceptAutocomplete(e);\r\n\r\n        } else if (selectionStart === selectionEnd) {\r\n          // Get the current line\r\n          const line = this._getLines(value, selectionStart).pop();\r\n          const matches = line?.match(/^\\s+/);\r\n\r\n          if (matches && matches[0]) {\r\n            e.preventDefault();\r\n\r\n            // Preserve indentation on inserting a new line\r\n            const indent = '\\n' + matches[0];\r\n            const updatedSelection = selectionStart + indent.length;\r\n\r\n            this._applyEdits({\r\n              // Insert indentation character at caret\r\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\r\n              // Update caret position\r\n              selectionStart: updatedSelection,\r\n              selectionEnd: updatedSelection,\r\n            });\r\n          }\r\n        }\r\n      } else if (BRACKET_PAIRS[e.key]) {\r\n        // If text is selected, wrap them in the characters\r\n        if (selectionStart !== selectionEnd) {\r\n          e.preventDefault();\r\n\r\n          this._applyEdits({\r\n            value:\r\n              value.substring(0, selectionStart) +\r\n              e.key +\r\n              value.substring(selectionStart, selectionEnd) +\r\n              BRACKET_PAIRS[e.key] +\r\n              value.substring(selectionEnd),\r\n            // Update caret position\r\n            selectionStart: selectionStart + 1,\r\n            selectionEnd: selectionEnd + 1,\r\n          });\r\n        }\r\n      } else if (\r\n        (isMacLike\r\n          ? // Trigger undo with ⌘+Z on Mac\r\n            e.metaKey && e.keyCode === KEYCODE_Z\r\n          : // Trigger undo with Ctrl+Z on other platforms\r\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\r\n        !e.shiftKey &&\r\n        !e.altKey\r\n      ) {\r\n        e.preventDefault();\r\n\r\n        this._undoEdit();\r\n      } else if (\r\n        (isMacLike\r\n          ? // Trigger redo with ⌘+Shift+Z on Mac\r\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\r\n          : isWindows\r\n          ? // Trigger redo with Ctrl+Y on Windows\r\n            e.ctrlKey && e.keyCode === KEYCODE_Y\r\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\r\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\r\n        !e.altKey\r\n      ) {\r\n        e.preventDefault();\r\n\r\n        this._redoEdit();\r\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\r\n        e.preventDefault();\r\n\r\n        // Toggle capturing tab key so users can focus away\r\n        this.capture = !this.capture;\r\n      }\r\n      if (e.keyCode !== 13 && e.keyCode !== 9) {\r\n        setTimeout(() => {\r\n          this.updateAutocompleteData();\r\n        }, 1);\r\n      }\r\n    },\r\n  },\r\n  render(h): VNode {\r\n    const lineNumberWidthCalculator = h(\r\n      'div',\r\n      {\r\n        attrs: {\r\n          class: 'prism-editor__line-width-calc',\r\n          style: 'height: 0px; visibility: hidden; pointer-events: none;',\r\n        },\r\n      },\r\n      '999'\r\n    );\r\n    const lineNumbers = h(\r\n      'div',\r\n      {\r\n        staticClass: 'prism-editor__line-numbers',\r\n        style: {\r\n          'min-height': this.lineNumbersHeight,\r\n        },\r\n        attrs: {\r\n          'aria-hidden': 'true',\r\n        },\r\n      },\r\n      [\r\n        lineNumberWidthCalculator,\r\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\r\n          return h('div', { attrs: { class: 'prism-editor__line-number token comment' } }, `${++index}`);\r\n        }),\r\n      ]\r\n    );\r\n\r\n    const autocompleteList = (this.autocompleteOpen && this.autocompleteData.length) ? h(\r\n      'ul',\r\n      {\r\n        staticClass: 'prism-editor__autocomplete',\r\n        style: {left: this.cursorOffset[0] + 'px', top: this.cursorOffset[1] + 'px'}\r\n      },\r\n      this.autocompleteData.map((data: AutocompleteEntry, i) => {\r\n        return h('li', {\r\n          key: data.text,\r\n          class: {selected: i == this.autocompleteIndex},\r\n          on: {\r\n            mousedown: ($event: MouseEvent) => {\r\n              this.acceptAutocomplete($event, i);\r\n            }\r\n          }\r\n        }, [data.label || data.text]);\r\n      })\r\n    ) : undefined;\r\n\r\n    const textarea = h('textarea', {\r\n      ref: 'textarea',\r\n      on: {\r\n        input: this.handleChange,\r\n        keydown: this.handleKeyDown,\r\n        click: ($event: MouseEvent) => {\r\n          this.autocompleteOpen = false;\r\n          this.$emit('click', $event);\r\n        },\r\n        keyup: ($event: KeyboardEvent) => {\r\n          this.$emit('keyup', $event);\r\n        },\r\n        focus: ($event: FocusEvent) => {\r\n          this._recordStateIfChange();\r\n          this.$emit('focus', $event);\r\n        },\r\n        blur: ($event: FocusEvent) => {\r\n          this.autocompleteOpen = false;\r\n          this.$emit('blur', $event);\r\n        },\r\n      },\r\n      staticClass: 'prism-editor__textarea',\r\n      class: {\r\n        'prism-editor__textarea--empty': this.isEmpty,\r\n      },\r\n      attrs: {\r\n        spellCheck: 'false',\r\n        autocapitalize: 'off',\r\n        autocomplete: 'off',\r\n        autocorrect: 'off',\r\n        'data-gramm': 'false',\r\n        placeholder: this.placeholder,\r\n        'data-testid': 'textarea',\r\n        readonly: this.readonly,\r\n      },\r\n      domProps: {\r\n        value: this.codeData,\r\n      },\r\n    });\r\n    const preview = h('pre', {\r\n      ref: 'pre',\r\n      staticClass: 'prism-editor__editor',\r\n      attrs: {\r\n        'data-testid': 'preview',\r\n      },\r\n      domProps: {\r\n        innerHTML: this.content,\r\n      },\r\n    });\r\n    const editorContainer = h('div', { staticClass: 'prism-editor__container' }, [textarea, preview]);\r\n    const wrapper = h('div', { staticClass: 'prism-editor-wrapper', ref: 'wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\r\n    return h('div', { staticClass: 'prism-editor-component' }, [wrapper, autocompleteList]);\r\n  },\r\n});\r\n"],"names":["BRACKET_PAIRS","isWindows","global","test","navigator","platform","isMacLike","PrismEditor","Vue","extend","props","lineNumbers","type","Boolean","autoStyleLineNumbers","readonly","value","String","highlight","Function","required","tabSize","Number","insertSpaces","ignoreTabKey","placeholder","autocomplete","data","capture","history","stack","offset","lineNumbersHeight","codeData","autocompleteOpen","autocompleteIndex","autocompleteData","watch","immediate","handler","newVal","content","this","$nextTick","_this","setLineNumbersHeight","_this2","styleLineNumbers","nextTick","node","_this3","$el","querySelector","scrollIntoView","block","computed","isEmpty","length","lineNumbersCount","split","cursorOffset","input","$refs","textarea","wrapper","lines","substring","selectionEnd","font_size","parseFloat","getComputedStyle","getPropertyValue","line","Math","min","scrollLeft","clientWidth","scrollTop","mounted","_recordCurrentState","methods","updateAutocompleteData","old_length","splice","Infinity","max","acceptAutocomplete","event","option","preventDefault","undefined","suggestion","overlap","result","substr","text","join","cursor_pos","endsWith","selectionStart","_applyEdits","inserted_characters","setTimeout","_this4","pre","height","$editor","$lineNumbers","editorStyles","window","btlr","bblr","style","forEach","_recordChange","_getLines","position","_recordStateIfChange","record","last","_updateInput","overwrite","slice","count","extras","timestamp","Date","now","re","previous","pop","_this$_getLines$pop","match","current","_this$_getLines$pop2","startsWith","push","$emit","handleChange","e","target","_undoEdit","_redoEdit","handleKeyDown","$listeners","keydown","defaultPrevented","keyCode","stopPropagation","blur","tabCharacter","repeat","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","i","startLineText","updatedSelection","hasSelection","matches","indent","key","metaKey","ctrlKey","altKey","_this5","render","h","lineNumberWidthCalculator","attrs","staticClass","Array","from","keys","_","index","autocompleteList","left","top","selected","_this6","on","mousedown","$event","label","ref","click","keyup","focus","spellCheck","autocapitalize","autocorrect","domProps","preview","innerHTML","editorContainer"],"mappings":"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"}